<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Physics Rope & Chain</title>
    <link rel="stylesheet" src="styles.css">
  </head>
  <body>
    <!-- Панель с подсказками для пользователя 
         Panel with user key hints -->
    <div id="info">
      Press <b>R</b> for Rope, <b>C</b> for Chain — Current:
      <span id="mode">Rope</span>
    </div>
    <canvas id="canvas"></canvas>
    <script>
      // Получаем canvas и 2D-контекст
      // Get canvas and 2D drawing context
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = innerWidth;
      canvas.height = innerHeight;

      // Физические параметры:
      // gravity — сила гравитации (Gravity force)
      // friction — трение, замедляет движение (Friction to slow movement)
      // constraintIterations — число итераций фиксации расстояния (Number of constraint iterations)
      const gravity = 0.5;
      const friction = 0.98;
      const constraintIterations = 30;

      // Расстояние между точками и количество сегментов
      // Spacing between points and number of segments
      let spacing = 25;
      let segmentCount = 30;
      let isChain = false; // Режим: false = верёвка, true = цепь
      // Mode: false = rope, true = chain

      // Класс точки — узел в нашей верёвке или цепи
      // Point class — a node in the rope or chain
      class Point {
        constructor(x, y, pinned = false) {
          this.x = x;
          this.y = y;
          this.oldx = x; // Для вычисления скорости — предыдущая позиция
          this.oldy = y;
          this.pinned = pinned; // Закреплена ли точка (не двигается)
        }

        update() {
          if (this.pinned) return; // Закреплённые точки не двигаются
          // Вычисляем скорость по разнице с предыдущей позицией и применяем трение
          let vx = (this.x - this.oldx) * friction;
          let vy = (this.y - this.oldy) * friction;

          this.oldx = this.x;
          this.oldy = this.y;
          // Обновляем позицию с учетом скорости и гравитации
          this.x += vx;
          this.y += vy + gravity;
        }

        constrain() {
          // Ограничиваем точку в пределах canvas
          this.x = Math.max(0, Math.min(canvas.width, this.x));
          this.y = Math.max(0, Math.min(canvas.height, this.y));
        }
      }

      // Класс связи между двумя точками (стик)
      // Stick class connecting two points
      class Stick {
        constructor(p0, p1) {
          this.p0 = p0;
          this.p1 = p1;
          this.length = spacing; // Длина связки должна быть постоянной
        }

        update() {
          // Рассчитываем текущее расстояние между точками
          let dx = this.p1.x - this.p0.x;
          let dy = this.p1.y - this.p0.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          let diff = dist - this.length;
          let percent = diff / dist / 2;

          let offsetX = dx * percent;
          let offsetY = dy * percent;

          // Сдвигаем точки для сохранения длины стека, если они не закреплены
          if (!this.p0.pinned) {
            this.p0.x += offsetX;
            this.p0.y += offsetY;
          }
          if (!this.p1.pinned) {
            this.p1.x -= offsetX;
            this.p1.y -= offsetY;
          }
        }

        draw() {
          if (isChain) {
            // Рисуем цепь: звенья — эллипсы, повернутые по направлению
            ctx.save();
            const dx = this.p1.x - this.p0.x;
            const dy = this.p1.y - this.p0.y;
            const angle = Math.atan2(dy, dx);
            ctx.translate(this.p0.x, this.p0.y);
            ctx.rotate(angle);
            ctx.strokeStyle = "#777";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.ellipse(spacing / 2, 0, spacing / 2.2, 6, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          } else {
            // Рисуем верёвку — простая линия между точками
            ctx.strokeStyle = "#fa0";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.p0.x, this.p0.y);
            ctx.lineTo(this.p1.x, this.p1.y);
            ctx.stroke();
          }
        }
      }

      let points = [],
        sticks = [];

      // Создаем структуру верёвки или цепи
      // Create rope or chain structure
      function createRopeOrChain() {
        points = [];
        sticks = [];
        const usedSpacing = isChain ? 18 : 25; // Для цепи — более плотные звенья
        spacing = usedSpacing;

        for (let i = 0; i < segmentCount; i++) {
          const pinned = i === 0; // Закрепляем первый узел
          const p = new Point(300, 100 + i * spacing, pinned);
          points.push(p);
          if (i > 0) sticks.push(new Stick(points[i - 1], p));
        }
      }

      // Обновление отображаемого режима (rope / chain)
      // Update displayed mode text
      function updateModeText() {
        document.getElementById("mode").textContent = isChain
          ? "Chain"
          : "Rope";
      }

      // Инициализация
      createRopeOrChain();
      updateModeText();

      let selected = null; // Текущая выбранная точка для перетаскивания
      let isDragging = false;

      // Обработка начала перетаскивания мышью
      // Mouse down event - start dragging point if close
      canvas.addEventListener("mousedown", (e) => {
        const mx = e.clientX,
          my = e.clientY;
        for (const p of points) {
          const dx = p.x - mx,
            dy = p.y - my;
          // Проверяем, находится ли мышь близко к точке (радиус ~20px)
          if (dx * dx + dy * dy < 400) {
            selected = p;
            selected.oldx = mx;
            selected.oldy = my;
            selected.x = mx;
            selected.y = my;
            isDragging = true;
            break;
          }
        }
      });

      // Обработка движения мыши - перетаскиваем выбранную точку
      // Mouse move event - drag selected point
      canvas.addEventListener("mousemove", (e) => {
        if (isDragging && selected) {
          selected.x = e.clientX;
          selected.y = e.clientY;
          selected.oldx = e.clientX;
          selected.oldy = e.clientY;
        }
      });

      // Обработка отпускания кнопки мыши или ухода курсора с canvas
      // Mouse up or leave - stop dragging
      ["mouseup", "mouseleave"].forEach((evt) =>
        canvas.addEventListener(evt, () => {
          selected = null;
          isDragging = false;
        })
      );

      // Обработка клавиш:
      // R - веревка, C - цепь, + / = - добавить сегменты, - - убрать сегменты
      window.addEventListener("keydown", (e) => {
        const key = e.key.toLowerCase();
        if (key === "r") {
          isChain = false;
          createRopeOrChain();
          updateModeText();
        } else if (key === "c") {
          isChain = true;
          createRopeOrChain();
          updateModeText();
        } else if (key === "+" || key === "=") {
          segmentCount += 5;
          createRopeOrChain();
        } else if (key === "-") {
          segmentCount = Math.max(5, segmentCount - 5);
          createRopeOrChain();
        }
      });

      // Главный цикл анимации
      // Main animation loop
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Обновляем положение всех точек
        for (const p of points) p.update();

        // Несколько итераций фиксации длины связей
        for (let i = 0; i < constraintIterations; i++) {
          for (const s of sticks) s.update();
          for (const p of points) p.constrain();
        }

        // Рисуем все связи
        for (const s of sticks) s.draw();

        requestAnimationFrame(animate);
      }

      animate();

      // Обновляем размеры canvas при изменении окна
      // Update canvas size on window resize
      window.addEventListener("resize", () => {
        canvas.width = innerWidth;
        canvas.height = innerHeight;
      });
    </script>
  </body>
</html>
